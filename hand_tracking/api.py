import asyncio
import json
import numpy as np
import torch
from core.model import RecognitionModel
from collections import deque
import time
import os
import sys
from dotenv import load_dotenv
from concurrent.futures import ThreadPoolExecutor

try:
    import websockets
    from websockets.asyncio.server import serve
except ImportError:
    print("ERROR: websockets package not installed!")
    print("Run: pip install websockets")
    sys.exit(1)

# Load environment variables
load_dotenv()

# Configuration from .env
PORT = int(os.getenv('PORT', 5000))
HOST = os.getenv('HOST', '0.0.0.0')
MAX_CONNECTIONS = int(os.getenv('MAX_CONNECTIONS', 10))
WORKER_THREADS = int(os.getenv('WORKER_THREADS', 4))

# Load signs dynamically from signs.json (generated by train.py)
SIGNS_FILE = "signs.json"
if os.path.exists(SIGNS_FILE):
    import json as _json
    with open(SIGNS_FILE, "r") as f:
        SIGNS = _json.load(f)
    print(f"Loaded {len(SIGNS)} signs from {SIGNS_FILE}")
else:
    # Fallback: discover signs from .npy files in data/
    if os.path.exists("data"):
        SIGNS = sorted([
            os.path.splitext(f)[0]
            for f in os.listdir("data")
            if f.endswith(".npy")
        ])
    else:
        SIGNS = []

if not SIGNS:
    print("ERROR: No signs found!")
    print("Run train.py in data_download/ to extract data and train the model.")
    sys.exit(1)

# Check if training data exists
if not os.path.exists(f"data/{SIGNS[0]}.npy"):
    print("ERROR: Training data not found!")
    print("Run train.py in data_download/ to extract data and train the model.")
    sys.exit(1)

sample_data = np.load(f"data/{SIGNS[0]}.npy")
input_size = sample_data.shape[2]

# Check if model exists
if not os.path.exists("recognition_model.pth"):
    print("ERROR: Trained model not found!")
    print("Run train.py in data_download/ to train the model.")
    sys.exit(1)

# Configuration constants
CONFIDENCE_THRESHOLD = 0.6
SEQUENCE_LENGTH = 30  # Number of frames needed for prediction
PREDICTION_STRIDE = 15  # Process prediction every N frames after SEQUENCE_LENGTH
DEBOUNCE_TIME = 2.0
MAX_TEXT_LENGTH = 100

# Load model
model = RecognitionModel(
    input_size=input_size,
    hidden_size=128,
    num_layers=2,
    output_size=len(SIGNS),
    dropout=0.0
)
model.load_state_dict(torch.load("recognition_model.pth"))
model.eval()

# Thread pool for CPU-intensive tasks (model inference)
executor = ThreadPoolExecutor(max_workers=WORKER_THREADS)

print(f"Model loaded successfully. Input size: {input_size}")
print(f"Configuration: SEQUENCE_LENGTH={SEQUENCE_LENGTH}, PREDICTION_STRIDE={PREDICTION_STRIDE}")


class GestureRecognitionSession:
    """Handles gesture recognition state for a single client connection"""

    def __init__(self, session_id, websocket):
        self.session_id = session_id
        self.websocket = websocket
        self.frame_queue = deque(maxlen=SEQUENCE_LENGTH + PREDICTION_STRIDE)
        self.text_sequence = []
        self.last_prediction = None
        self.last_prediction_time = 0
        self.frame_count = 0
        self.frames_since_last_prediction = 0
        self.lock = asyncio.Lock()

    def predict_sync(self, sequence):
        """Synchronous prediction (runs in thread pool)"""
        if len(sequence) < SEQUENCE_LENGTH:
            return None, 0.0

        seq = list(sequence)[:SEQUENCE_LENGTH]

        x = torch.tensor(np.array(seq), dtype=torch.float32)
        x = x.unsqueeze(0)  # (1, 30, input_size)

        with torch.no_grad():
            output = model(x)
            probabilities = torch.softmax(output, dim=1)
            conf, predicted = torch.max(probabilities, dim=1)

        # Debug: show top-3 predictions
        top3_probs, top3_idx = torch.topk(probabilities[0], min(3, len(SIGNS)))
        top3 = [(SIGNS[i], f"{p:.1%}") for i, p in zip(top3_idx.tolist(), top3_probs.tolist())]
        print(f"  [DEBUG] Top predictions: {top3}")

        if conf.item() < CONFIDENCE_THRESHOLD:
            return None, conf.item()

        return SIGNS[predicted.item()], conf.item()

    async def predict(self, sequence):
        """Async wrapper for prediction"""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(executor, self.predict_sync, sequence)

    async def send(self, message):
        """Send a JSON message to the client"""
        try:
            await self.websocket.send(json.dumps(message))
        except Exception as e:
            print(f"[Session {self.session_id}] Error sending: {e}")

    async def send_prediction(self, prediction, confidence, frame_count):
        """Send prediction result to client"""
        await self.send({
            'type': 'prediction',
            'prediction': prediction,
            'confidence': confidence,
            'frame_count': frame_count,
            'text_sequence': self.text_sequence.copy(),
            'queue_size': len(self.frame_queue)
        })

    async def send_status(self, status_type, message_text):
        """Send status message to client"""
        await self.send({
            'type': 'status',
            'status': status_type,
            'message': message_text,
            'frame_count': self.frame_count,
            'queue_size': len(self.frame_queue)
        })

    async def add_frame(self, frame_data):
        """Add a frame to the queue and check if prediction should be triggered"""
        async with self.lock:
            self.frame_queue.append(frame_data)
            self.frame_count += 1
            self.frames_since_last_prediction += 1

            queue_size = len(self.frame_queue)
            should_predict = False

            if queue_size >= SEQUENCE_LENGTH + PREDICTION_STRIDE:
                if self.frames_since_last_prediction >= PREDICTION_STRIDE:
                    should_predict = True
                    queue_copy = list(self.frame_queue)

        if should_predict:
            prediction, confidence = await self.predict(queue_copy)

            async with self.lock:
                if prediction is not None:
                    current_time = time.time()
                    time_since_last = current_time - self.last_prediction_time

                    if (self.last_prediction != prediction or time_since_last > DEBOUNCE_TIME):
                        self.text_sequence.append(prediction)
                        self.last_prediction = prediction
                        self.last_prediction_time = current_time

                        if len(self.text_sequence) > MAX_TEXT_LENGTH:
                            self.text_sequence.pop(0)

                        print(f"[Session {self.session_id}] Detected: {prediction} ({confidence:.1%}) at frame {self.frame_count}")

            await self.send_prediction(prediction, confidence, self.frame_count)

            async with self.lock:
                for _ in range(PREDICTION_STRIDE):
                    if len(self.frame_queue) > 0:
                        self.frame_queue.popleft()
                self.frames_since_last_prediction = 0

    async def reset_buffer(self):
        """Reset the frame buffer"""
        async with self.lock:
            self.frame_queue.clear()
            self.frame_count = 0
            self.frames_since_last_prediction = 0
        await self.send_status('reset', 'Buffer reset')

    async def clear_text(self):
        """Clear accumulated text"""
        async with self.lock:
            self.text_sequence = []
            self.last_prediction = None
        await self.send_status('cleared', 'Text sequence cleared')

    async def get_status(self):
        """Get current status"""
        async with self.lock:
            return {
                'frame_count': self.frame_count,
                'queue_size': len(self.frame_queue),
                'text_sequence': self.text_sequence.copy(),
                'frames_since_last_prediction': self.frames_since_last_prediction
            }


class ConnectionPool:
    """Manages active connections with limits"""

    def __init__(self, max_connections):
        self.max_connections = max_connections
        self.active_connections = 0
        self.session_counter = 0
        self.lock = asyncio.Lock()

    async def can_accept(self):
        async with self.lock:
            return self.active_connections < self.max_connections

    async def add_connection(self):
        async with self.lock:
            self.active_connections += 1
            self.session_counter += 1
            return self.session_counter

    async def remove_connection(self):
        async with self.lock:
            self.active_connections = max(0, self.active_connections - 1)

    async def get_stats(self):
        async with self.lock:
            return {
                "active": self.active_connections,
                "max": self.max_connections,
                "total_sessions": self.session_counter
            }


# Global connection pool
connection_pool = ConnectionPool(MAX_CONNECTIONS)


async def handle_client(websocket):
    """Handle a single WebSocket client connection"""
    addr = websocket.remote_address

    if not await connection_pool.can_accept():
        print(f"[REJECTED] {addr} - Server at capacity")
        await websocket.send(json.dumps({
            'type': 'error',
            'message': 'Server at maximum capacity'
        }))
        return

    session_id = await connection_pool.add_connection()
    print(f"[NEW CONNECTION] Session {session_id} from {addr}")

    session = GestureRecognitionSession(session_id, websocket)
    await session.send_status('connected', 'Session started, ready to receive frames')

    try:
        async for raw_message in websocket:
            try:
                message = json.loads(raw_message)
                command = message.get('command', 'frame')

                if command == 'frame':
                    frame_data = np.array(message['data'])
                    await session.add_frame(frame_data)

                elif command == 'reset':
                    await session.reset_buffer()

                elif command == 'clear':
                    await session.clear_text()

                elif command == 'status':
                    status = await session.get_status()
                    await session.send({
                        'type': 'status',
                        **status
                    })

                elif command == 'server_stats':
                    stats = await connection_pool.get_stats()
                    await session.send({
                        'type': 'stats',
                        'stats': stats
                    })

                else:
                    await session.send({
                        'type': 'error',
                        'message': f'Unknown command: {command}'
                    })

            except json.JSONDecodeError as e:
                await session.send({
                    'type': 'error',
                    'message': f'Invalid JSON: {str(e)}'
                })
            except Exception as e:
                print(f"[ERROR] Session {session_id}: {e}")
                await session.send({
                    'type': 'error',
                    'message': str(e)
                })

    except websockets.ConnectionClosed:
        print(f"[DISCONNECTED] Session {session_id} - Connection closed")
    except Exception as e:
        print(f"[ERROR] Session {session_id}: {e}")
    finally:
        await connection_pool.remove_connection()
        print(f"[DISCONNECTED] Session {session_id} from {addr}")


async def start_server():
    """Start the WebSocket server"""
    print(f"[STARTING] Gesture Recognition API Server (WebSocket)")
    print(f"[LISTENING] on ws://{HOST}:{PORT}")
    print(f"[MODEL] Loaded with {len(SIGNS)} signs: {SIGNS}")
    print(f"[POOL] Max connections: {MAX_CONNECTIONS}")
    print(f"[WORKERS] Thread pool size: {WORKER_THREADS}")
    print(f"[CONFIG] Sequence length: {SEQUENCE_LENGTH}, Prediction stride: {PREDICTION_STRIDE}")
    print(f"[READY] Waiting for connections...")
    print("\nPress Ctrl+C to stop the server\n")

    async with serve(handle_client, HOST, PORT) as server:
        await server.serve_forever()


def main():
    """Main entry point"""
    try:
        asyncio.run(start_server())
    except KeyboardInterrupt:
        print("\n[SHUTTING DOWN] Server stopped")
    finally:
        executor.shutdown(wait=True)
        print("[CLEANUP] Thread pool shut down")


if __name__ == '__main__':
    main()
